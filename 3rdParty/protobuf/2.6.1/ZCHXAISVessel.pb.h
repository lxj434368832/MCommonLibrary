// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZCHXAISVessel.proto

#ifndef PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED
#define PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace zhichenhaixin {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

class VesselInfo;
class VesselTrack;
class AIS;
class AISList;

enum EPFD {
  UNDEFINED = 0,
  GPS = 1,
  GLONASS = 2,
  COMBINED_GPS_AND_GLONASS = 3,
  LORAN_C = 4,
  CHAYKA = 5,
  INTEGRATED_NAVIGATION_SYSTEM = 6,
  SURVEYED = 7,
  GALILEO = 8
};
bool EPFD_IsValid(int value);
const EPFD EPFD_MIN = UNDEFINED;
const EPFD EPFD_MAX = GALILEO;
const int EPFD_ARRAYSIZE = EPFD_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPFD_descriptor();
inline const ::std::string& EPFD_Name(EPFD value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPFD_descriptor(), value);
}
inline bool EPFD_Parse(
    const ::std::string& name, EPFD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPFD>(
    EPFD_descriptor(), name, value);
}
enum NAVI_STATUS {
  UNDER_WAY_USING_ENGINE = 0,
  AT_ANCHOR = 1,
  NOT_UNDER_COMMAND = 2,
  RESTRICTED_MANOEUVER = 3,
  CONSTRAINED_BY_DRAUGHT = 4,
  MOORED = 5,
  AGROUND = 6,
  ENGAGED_IN_FISHING = 7,
  UNDER_WAY_SAILING = 8,
  RESERVED_FOR_FUTURE_AMENDMENT_FOR_HSC = 9,
  RESERVED_FOR_FUTURE_AMENDMENT_FOR_WIG = 10,
  RESERVED_FOR_FUTURE_USE_1 = 11,
  RESERVED_FOR_FUTURE_USE_2 = 12,
  RESERVED_FOR_FUTURE_USE_3 = 13,
  RESERVED_FOR_FUTURE_USE_4 = 14,
  NOT_DEFINED = 15
};
bool NAVI_STATUS_IsValid(int value);
const NAVI_STATUS NAVI_STATUS_MIN = UNDER_WAY_USING_ENGINE;
const NAVI_STATUS NAVI_STATUS_MAX = NOT_DEFINED;
const int NAVI_STATUS_ARRAYSIZE = NAVI_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* NAVI_STATUS_descriptor();
inline const ::std::string& NAVI_STATUS_Name(NAVI_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    NAVI_STATUS_descriptor(), value);
}
inline bool NAVI_STATUS_Parse(
    const ::std::string& name, NAVI_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVI_STATUS>(
    NAVI_STATUS_descriptor(), name, value);
}
// ===================================================================

class VesselInfo : public ::google::protobuf::Message {
 public:
  VesselInfo();
  virtual ~VesselInfo();

  VesselInfo(const VesselInfo& from);

  inline VesselInfo& operator=(const VesselInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VesselInfo& default_instance();

  void Swap(VesselInfo* other);

  // implements Message ----------------------------------------------

  VesselInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VesselInfo& from);
  void MergeFrom(const VesselInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required string shipType = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShipTypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required int32 imo = 4;
  inline bool has_imo() const;
  inline void clear_imo();
  static const int kImoFieldNumber = 4;
  inline ::google::protobuf::int32 imo() const;
  inline void set_imo(::google::protobuf::int32 value);

  // required string callSign = 5;
  inline bool has_callsign() const;
  inline void clear_callsign();
  static const int kCallSignFieldNumber = 5;
  inline const ::std::string& callsign() const;
  inline void set_callsign(const ::std::string& value);
  inline void set_callsign(const char* value);
  inline void set_callsign(const char* value, size_t size);
  inline ::std::string* mutable_callsign();
  inline ::std::string* release_callsign();
  inline void set_allocated_callsign(::std::string* callsign);

  // required string shipName = 6;
  inline bool has_shipname() const;
  inline void clear_shipname();
  static const int kShipNameFieldNumber = 6;
  inline const ::std::string& shipname() const;
  inline void set_shipname(const ::std::string& value);
  inline void set_shipname(const char* value);
  inline void set_shipname(const char* value, size_t size);
  inline ::std::string* mutable_shipname();
  inline ::std::string* release_shipname();
  inline void set_allocated_shipname(::std::string* shipname);

  // required int32 cargoType = 7;
  inline bool has_cargotype() const;
  inline void clear_cargotype();
  static const int kCargoTypeFieldNumber = 7;
  inline ::google::protobuf::int32 cargotype() const;
  inline void set_cargotype(::google::protobuf::int32 value);

  // required string country = 8;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 8;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // required string vendorID = 9;
  inline bool has_vendorid() const;
  inline void clear_vendorid();
  static const int kVendorIDFieldNumber = 9;
  inline const ::std::string& vendorid() const;
  inline void set_vendorid(const ::std::string& value);
  inline void set_vendorid(const char* value);
  inline void set_vendorid(const char* value, size_t size);
  inline ::std::string* mutable_vendorid();
  inline ::std::string* release_vendorid();
  inline void set_allocated_vendorid(::std::string* vendorid);

  // required int32 shipLength = 10;
  inline bool has_shiplength() const;
  inline void clear_shiplength();
  static const int kShipLengthFieldNumber = 10;
  inline ::google::protobuf::int32 shiplength() const;
  inline void set_shiplength(::google::protobuf::int32 value);

  // required int32 shipWidth = 11;
  inline bool has_shipwidth() const;
  inline void clear_shipwidth();
  static const int kShipWidthFieldNumber = 11;
  inline ::google::protobuf::int32 shipwidth() const;
  inline void set_shipwidth(::google::protobuf::int32 value);

  // required int32 toBow = 12;
  inline bool has_tobow() const;
  inline void clear_tobow();
  static const int kToBowFieldNumber = 12;
  inline ::google::protobuf::int32 tobow() const;
  inline void set_tobow(::google::protobuf::int32 value);

  // required int32 toStern = 13;
  inline bool has_tostern() const;
  inline void clear_tostern();
  static const int kToSternFieldNumber = 13;
  inline ::google::protobuf::int32 tostern() const;
  inline void set_tostern(::google::protobuf::int32 value);

  // required int32 toPort = 14;
  inline bool has_toport() const;
  inline void clear_toport();
  static const int kToPortFieldNumber = 14;
  inline ::google::protobuf::int32 toport() const;
  inline void set_toport(::google::protobuf::int32 value);

  // required int32 toStarboard = 15;
  inline bool has_tostarboard() const;
  inline void clear_tostarboard();
  static const int kToStarboardFieldNumber = 15;
  inline ::google::protobuf::int32 tostarboard() const;
  inline void set_tostarboard(::google::protobuf::int32 value);

  // required .com.zhichenhaixin.proto.EPFD fixType = 16;
  inline bool has_fixtype() const;
  inline void clear_fixtype();
  static const int kFixTypeFieldNumber = 16;
  inline ::com::zhichenhaixin::proto::EPFD fixtype() const;
  inline void set_fixtype(::com::zhichenhaixin::proto::EPFD value);

  // required string eta = 17;
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 17;
  inline const ::std::string& eta() const;
  inline void set_eta(const ::std::string& value);
  inline void set_eta(const char* value);
  inline void set_eta(const char* value, size_t size);
  inline ::std::string* mutable_eta();
  inline ::std::string* release_eta();
  inline void set_allocated_eta(::std::string* eta);

  // required float draught = 18;
  inline bool has_draught() const;
  inline void clear_draught();
  static const int kDraughtFieldNumber = 18;
  inline float draught() const;
  inline void set_draught(float value);

  // required string dest = 19;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 19;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // required uint64 UTC = 20;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 20;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.VesselInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_imo();
  inline void clear_has_imo();
  inline void set_has_callsign();
  inline void clear_has_callsign();
  inline void set_has_shipname();
  inline void clear_has_shipname();
  inline void set_has_cargotype();
  inline void clear_has_cargotype();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_vendorid();
  inline void clear_has_vendorid();
  inline void set_has_shiplength();
  inline void clear_has_shiplength();
  inline void set_has_shipwidth();
  inline void clear_has_shipwidth();
  inline void set_has_tobow();
  inline void clear_has_tobow();
  inline void set_has_tostern();
  inline void clear_has_tostern();
  inline void set_has_toport();
  inline void clear_has_toport();
  inline void set_has_tostarboard();
  inline void clear_has_tostarboard();
  inline void set_has_fixtype();
  inline void clear_has_fixtype();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_draught();
  inline void clear_has_draught();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* shiptype_;
  ::google::protobuf::int32 mmsi_;
  ::google::protobuf::int32 imo_;
  ::std::string* callsign_;
  ::std::string* shipname_;
  ::std::string* country_;
  ::google::protobuf::int32 cargotype_;
  ::google::protobuf::int32 shiplength_;
  ::std::string* vendorid_;
  ::google::protobuf::int32 shipwidth_;
  ::google::protobuf::int32 tobow_;
  ::google::protobuf::int32 tostern_;
  ::google::protobuf::int32 toport_;
  ::google::protobuf::int32 tostarboard_;
  int fixtype_;
  ::std::string* eta_;
  ::std::string* dest_;
  ::google::protobuf::uint64 utc_;
  float draught_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static VesselInfo* default_instance_;
};
// -------------------------------------------------------------------

class VesselTrack : public ::google::protobuf::Message {
 public:
  VesselTrack();
  virtual ~VesselTrack();

  VesselTrack(const VesselTrack& from);

  inline VesselTrack& operator=(const VesselTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VesselTrack& default_instance();

  void Swap(VesselTrack* other);

  // implements Message ----------------------------------------------

  VesselTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VesselTrack& from);
  void MergeFrom(const VesselTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required string shiptype = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShiptypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
  inline bool has_navstatus() const;
  inline void clear_navstatus();
  static const int kNavStatusFieldNumber = 4;
  inline ::com::zhichenhaixin::proto::NAVI_STATUS navstatus() const;
  inline void set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value);

  // required float rot = 5;
  inline bool has_rot() const;
  inline void clear_rot();
  static const int kRotFieldNumber = 5;
  inline float rot() const;
  inline void set_rot(float value);

  // required float sog = 6;
  inline bool has_sog() const;
  inline void clear_sog();
  static const int kSogFieldNumber = 6;
  inline float sog() const;
  inline void set_sog(float value);

  // required float lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline float lon() const;
  inline void set_lon(float value);

  // required float lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline float lat() const;
  inline void set_lat(float value);

  // required float cog = 9;
  inline bool has_cog() const;
  inline void clear_cog();
  static const int kCogFieldNumber = 9;
  inline float cog() const;
  inline void set_cog(float value);

  // required float heading = 10;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 10;
  inline float heading() const;
  inline void set_heading(float value);

  // required uint64 UTC = 11;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 11;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.VesselTrack)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_navstatus();
  inline void clear_has_navstatus();
  inline void set_has_rot();
  inline void clear_has_rot();
  inline void set_has_sog();
  inline void clear_has_sog();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* shiptype_;
  ::google::protobuf::int32 mmsi_;
  int navstatus_;
  float rot_;
  float sog_;
  float lon_;
  float lat_;
  float cog_;
  float heading_;
  ::google::protobuf::uint64 utc_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static VesselTrack* default_instance_;
};
// -------------------------------------------------------------------

class AIS : public ::google::protobuf::Message {
 public:
  AIS();
  virtual ~AIS();

  AIS(const AIS& from);

  inline AIS& operator=(const AIS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIS& default_instance();

  void Swap(AIS* other);

  // implements Message ----------------------------------------------

  AIS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIS& from);
  void MergeFrom(const AIS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // required string sourceId = 2;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceIdFieldNumber = 2;
  inline const ::std::string& sourceid() const;
  inline void set_sourceid(const ::std::string& value);
  inline void set_sourceid(const char* value);
  inline void set_sourceid(const char* value, size_t size);
  inline ::std::string* mutable_sourceid();
  inline ::std::string* release_sourceid();
  inline void set_allocated_sourceid(::std::string* sourceid);

  // optional .com.zhichenhaixin.proto.VesselInfo vesselInfo = 3;
  inline bool has_vesselinfo() const;
  inline void clear_vesselinfo();
  static const int kVesselInfoFieldNumber = 3;
  inline const ::com::zhichenhaixin::proto::VesselInfo& vesselinfo() const;
  inline ::com::zhichenhaixin::proto::VesselInfo* mutable_vesselinfo();
  inline ::com::zhichenhaixin::proto::VesselInfo* release_vesselinfo();
  inline void set_allocated_vesselinfo(::com::zhichenhaixin::proto::VesselInfo* vesselinfo);

  // optional .com.zhichenhaixin.proto.VesselTrack vesselTrack = 4;
  inline bool has_vesseltrack() const;
  inline void clear_vesseltrack();
  static const int kVesselTrackFieldNumber = 4;
  inline const ::com::zhichenhaixin::proto::VesselTrack& vesseltrack() const;
  inline ::com::zhichenhaixin::proto::VesselTrack* mutable_vesseltrack();
  inline ::com::zhichenhaixin::proto::VesselTrack* release_vesseltrack();
  inline void set_allocated_vesseltrack(::com::zhichenhaixin::proto::VesselTrack* vesseltrack);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AIS)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_vesselinfo();
  inline void clear_has_vesselinfo();
  inline void set_has_vesseltrack();
  inline void clear_has_vesseltrack();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sourceid_;
  ::com::zhichenhaixin::proto::VesselInfo* vesselinfo_;
  ::com::zhichenhaixin::proto::VesselTrack* vesseltrack_;
  ::google::protobuf::int32 flag_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AIS* default_instance_;
};
// -------------------------------------------------------------------

class AISList : public ::google::protobuf::Message {
 public:
  AISList();
  virtual ~AISList();

  AISList(const AISList& from);

  inline AISList& operator=(const AISList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISList& default_instance();

  void Swap(AISList* other);

  // implements Message ----------------------------------------------

  AISList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISList& from);
  void MergeFrom(const AISList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 UTC = 1;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 1;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // repeated .com.zhichenhaixin.proto.AIS ais = 2;
  inline int ais_size() const;
  inline void clear_ais();
  static const int kAisFieldNumber = 2;
  inline const ::com::zhichenhaixin::proto::AIS& ais(int index) const;
  inline ::com::zhichenhaixin::proto::AIS* mutable_ais(int index);
  inline ::com::zhichenhaixin::proto::AIS* add_ais();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >&
      ais() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >*
      mutable_ais();

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISList)
 private:
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 utc_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS > ais_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISList* default_instance_;
};
// ===================================================================


// ===================================================================

// VesselInfo

// required string id = 1;
inline bool VesselInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VesselInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VesselInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VesselInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& VesselInfo::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.id)
  return *id_;
}
inline void VesselInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.id)
}
inline void VesselInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.id)
}
inline void VesselInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.id)
}
inline ::std::string* VesselInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.id)
  return id_;
}
inline ::std::string* VesselInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.id)
}

// required int32 mmsi = 2;
inline bool VesselInfo::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VesselInfo::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VesselInfo::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VesselInfo::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 VesselInfo::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.mmsi)
  return mmsi_;
}
inline void VesselInfo::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.mmsi)
}

// required string shipType = 3;
inline bool VesselInfo::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VesselInfo::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VesselInfo::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VesselInfo::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& VesselInfo::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipType)
  return *shiptype_;
}
inline void VesselInfo::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline void VesselInfo::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline void VesselInfo::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline ::std::string* VesselInfo::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.shipType)
  return shiptype_;
}
inline ::std::string* VesselInfo::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.shipType)
}

// required int32 imo = 4;
inline bool VesselInfo::has_imo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VesselInfo::set_has_imo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VesselInfo::clear_has_imo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VesselInfo::clear_imo() {
  imo_ = 0;
  clear_has_imo();
}
inline ::google::protobuf::int32 VesselInfo::imo() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.imo)
  return imo_;
}
inline void VesselInfo::set_imo(::google::protobuf::int32 value) {
  set_has_imo();
  imo_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.imo)
}

// required string callSign = 5;
inline bool VesselInfo::has_callsign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VesselInfo::set_has_callsign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VesselInfo::clear_has_callsign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VesselInfo::clear_callsign() {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_->clear();
  }
  clear_has_callsign();
}
inline const ::std::string& VesselInfo::callsign() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.callSign)
  return *callsign_;
}
inline void VesselInfo::set_callsign(const ::std::string& value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline void VesselInfo::set_callsign(const char* value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline void VesselInfo::set_callsign(const char* value, size_t size) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline ::std::string* VesselInfo::mutable_callsign() {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.callSign)
  return callsign_;
}
inline ::std::string* VesselInfo::release_callsign() {
  clear_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = callsign_;
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_callsign(::std::string* callsign) {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete callsign_;
  }
  if (callsign) {
    set_has_callsign();
    callsign_ = callsign;
  } else {
    clear_has_callsign();
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.callSign)
}

// required string shipName = 6;
inline bool VesselInfo::has_shipname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VesselInfo::set_has_shipname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VesselInfo::clear_has_shipname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VesselInfo::clear_shipname() {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_->clear();
  }
  clear_has_shipname();
}
inline const ::std::string& VesselInfo::shipname() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipName)
  return *shipname_;
}
inline void VesselInfo::set_shipname(const ::std::string& value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline void VesselInfo::set_shipname(const char* value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline void VesselInfo::set_shipname(const char* value, size_t size) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline ::std::string* VesselInfo::mutable_shipname() {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.shipName)
  return shipname_;
}
inline ::std::string* VesselInfo::release_shipname() {
  clear_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shipname_;
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_shipname(::std::string* shipname) {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shipname_;
  }
  if (shipname) {
    set_has_shipname();
    shipname_ = shipname;
  } else {
    clear_has_shipname();
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.shipName)
}

// required int32 cargoType = 7;
inline bool VesselInfo::has_cargotype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VesselInfo::set_has_cargotype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VesselInfo::clear_has_cargotype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VesselInfo::clear_cargotype() {
  cargotype_ = 0;
  clear_has_cargotype();
}
inline ::google::protobuf::int32 VesselInfo::cargotype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.cargoType)
  return cargotype_;
}
inline void VesselInfo::set_cargotype(::google::protobuf::int32 value) {
  set_has_cargotype();
  cargotype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.cargoType)
}

// required string country = 8;
inline bool VesselInfo::has_country() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VesselInfo::set_has_country() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VesselInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VesselInfo::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& VesselInfo::country() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.country)
  return *country_;
}
inline void VesselInfo::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.country)
}
inline void VesselInfo::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.country)
}
inline void VesselInfo::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.country)
}
inline ::std::string* VesselInfo::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.country)
  return country_;
}
inline ::std::string* VesselInfo::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.country)
}

// required string vendorID = 9;
inline bool VesselInfo::has_vendorid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VesselInfo::set_has_vendorid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VesselInfo::clear_has_vendorid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VesselInfo::clear_vendorid() {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_->clear();
  }
  clear_has_vendorid();
}
inline const ::std::string& VesselInfo::vendorid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.vendorID)
  return *vendorid_;
}
inline void VesselInfo::set_vendorid(const ::std::string& value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline void VesselInfo::set_vendorid(const char* value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline void VesselInfo::set_vendorid(const char* value, size_t size) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline ::std::string* VesselInfo::mutable_vendorid() {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.vendorID)
  return vendorid_;
}
inline ::std::string* VesselInfo::release_vendorid() {
  clear_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendorid_;
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_vendorid(::std::string* vendorid) {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendorid_;
  }
  if (vendorid) {
    set_has_vendorid();
    vendorid_ = vendorid;
  } else {
    clear_has_vendorid();
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.vendorID)
}

// required int32 shipLength = 10;
inline bool VesselInfo::has_shiplength() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VesselInfo::set_has_shiplength() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VesselInfo::clear_has_shiplength() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VesselInfo::clear_shiplength() {
  shiplength_ = 0;
  clear_has_shiplength();
}
inline ::google::protobuf::int32 VesselInfo::shiplength() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipLength)
  return shiplength_;
}
inline void VesselInfo::set_shiplength(::google::protobuf::int32 value) {
  set_has_shiplength();
  shiplength_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipLength)
}

// required int32 shipWidth = 11;
inline bool VesselInfo::has_shipwidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VesselInfo::set_has_shipwidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VesselInfo::clear_has_shipwidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VesselInfo::clear_shipwidth() {
  shipwidth_ = 0;
  clear_has_shipwidth();
}
inline ::google::protobuf::int32 VesselInfo::shipwidth() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipWidth)
  return shipwidth_;
}
inline void VesselInfo::set_shipwidth(::google::protobuf::int32 value) {
  set_has_shipwidth();
  shipwidth_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipWidth)
}

// required int32 toBow = 12;
inline bool VesselInfo::has_tobow() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VesselInfo::set_has_tobow() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VesselInfo::clear_has_tobow() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VesselInfo::clear_tobow() {
  tobow_ = 0;
  clear_has_tobow();
}
inline ::google::protobuf::int32 VesselInfo::tobow() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toBow)
  return tobow_;
}
inline void VesselInfo::set_tobow(::google::protobuf::int32 value) {
  set_has_tobow();
  tobow_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toBow)
}

// required int32 toStern = 13;
inline bool VesselInfo::has_tostern() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VesselInfo::set_has_tostern() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VesselInfo::clear_has_tostern() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VesselInfo::clear_tostern() {
  tostern_ = 0;
  clear_has_tostern();
}
inline ::google::protobuf::int32 VesselInfo::tostern() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toStern)
  return tostern_;
}
inline void VesselInfo::set_tostern(::google::protobuf::int32 value) {
  set_has_tostern();
  tostern_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toStern)
}

// required int32 toPort = 14;
inline bool VesselInfo::has_toport() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VesselInfo::set_has_toport() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VesselInfo::clear_has_toport() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VesselInfo::clear_toport() {
  toport_ = 0;
  clear_has_toport();
}
inline ::google::protobuf::int32 VesselInfo::toport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toPort)
  return toport_;
}
inline void VesselInfo::set_toport(::google::protobuf::int32 value) {
  set_has_toport();
  toport_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toPort)
}

// required int32 toStarboard = 15;
inline bool VesselInfo::has_tostarboard() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VesselInfo::set_has_tostarboard() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VesselInfo::clear_has_tostarboard() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VesselInfo::clear_tostarboard() {
  tostarboard_ = 0;
  clear_has_tostarboard();
}
inline ::google::protobuf::int32 VesselInfo::tostarboard() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toStarboard)
  return tostarboard_;
}
inline void VesselInfo::set_tostarboard(::google::protobuf::int32 value) {
  set_has_tostarboard();
  tostarboard_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toStarboard)
}

// required .com.zhichenhaixin.proto.EPFD fixType = 16;
inline bool VesselInfo::has_fixtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VesselInfo::set_has_fixtype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VesselInfo::clear_has_fixtype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VesselInfo::clear_fixtype() {
  fixtype_ = 0;
  clear_has_fixtype();
}
inline ::com::zhichenhaixin::proto::EPFD VesselInfo::fixtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.fixType)
  return static_cast< ::com::zhichenhaixin::proto::EPFD >(fixtype_);
}
inline void VesselInfo::set_fixtype(::com::zhichenhaixin::proto::EPFD value) {
  assert(::com::zhichenhaixin::proto::EPFD_IsValid(value));
  set_has_fixtype();
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.fixType)
}

// required string eta = 17;
inline bool VesselInfo::has_eta() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VesselInfo::set_has_eta() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VesselInfo::clear_has_eta() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VesselInfo::clear_eta() {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_->clear();
  }
  clear_has_eta();
}
inline const ::std::string& VesselInfo::eta() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.eta)
  return *eta_;
}
inline void VesselInfo::set_eta(const ::std::string& value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline void VesselInfo::set_eta(const char* value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline void VesselInfo::set_eta(const char* value, size_t size) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline ::std::string* VesselInfo::mutable_eta() {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.eta)
  return eta_;
}
inline ::std::string* VesselInfo::release_eta() {
  clear_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eta_;
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_eta(::std::string* eta) {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eta_;
  }
  if (eta) {
    set_has_eta();
    eta_ = eta;
  } else {
    clear_has_eta();
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.eta)
}

// required float draught = 18;
inline bool VesselInfo::has_draught() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VesselInfo::set_has_draught() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VesselInfo::clear_has_draught() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VesselInfo::clear_draught() {
  draught_ = 0;
  clear_has_draught();
}
inline float VesselInfo::draught() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.draught)
  return draught_;
}
inline void VesselInfo::set_draught(float value) {
  set_has_draught();
  draught_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.draught)
}

// required string dest = 19;
inline bool VesselInfo::has_dest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VesselInfo::set_has_dest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VesselInfo::clear_has_dest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VesselInfo::clear_dest() {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& VesselInfo::dest() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.dest)
  return *dest_;
}
inline void VesselInfo::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline void VesselInfo::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline void VesselInfo::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline ::std::string* VesselInfo::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.dest)
  return dest_;
}
inline ::std::string* VesselInfo::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.dest)
}

// required uint64 UTC = 20;
inline bool VesselInfo::has_utc() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VesselInfo::set_has_utc() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VesselInfo::clear_has_utc() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VesselInfo::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 VesselInfo::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.UTC)
  return utc_;
}
inline void VesselInfo::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.UTC)
}

// -------------------------------------------------------------------

// VesselTrack

// required string id = 1;
inline bool VesselTrack::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VesselTrack::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VesselTrack::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VesselTrack::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& VesselTrack::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.id)
  return *id_;
}
inline void VesselTrack::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.id)
}
inline void VesselTrack::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselTrack.id)
}
inline void VesselTrack::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselTrack.id)
}
inline ::std::string* VesselTrack::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselTrack.id)
  return id_;
}
inline ::std::string* VesselTrack::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselTrack::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselTrack.id)
}

// required int32 mmsi = 2;
inline bool VesselTrack::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VesselTrack::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VesselTrack::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VesselTrack::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 VesselTrack::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.mmsi)
  return mmsi_;
}
inline void VesselTrack::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.mmsi)
}

// required string shiptype = 3;
inline bool VesselTrack::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VesselTrack::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VesselTrack::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VesselTrack::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& VesselTrack::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.shiptype)
  return *shiptype_;
}
inline void VesselTrack::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline void VesselTrack::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline void VesselTrack::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline ::std::string* VesselTrack::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselTrack.shiptype)
  return shiptype_;
}
inline ::std::string* VesselTrack::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselTrack::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselTrack.shiptype)
}

// required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
inline bool VesselTrack::has_navstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VesselTrack::set_has_navstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VesselTrack::clear_has_navstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VesselTrack::clear_navstatus() {
  navstatus_ = 0;
  clear_has_navstatus();
}
inline ::com::zhichenhaixin::proto::NAVI_STATUS VesselTrack::navstatus() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.navStatus)
  return static_cast< ::com::zhichenhaixin::proto::NAVI_STATUS >(navstatus_);
}
inline void VesselTrack::set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value) {
  assert(::com::zhichenhaixin::proto::NAVI_STATUS_IsValid(value));
  set_has_navstatus();
  navstatus_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.navStatus)
}

// required float rot = 5;
inline bool VesselTrack::has_rot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VesselTrack::set_has_rot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VesselTrack::clear_has_rot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VesselTrack::clear_rot() {
  rot_ = 0;
  clear_has_rot();
}
inline float VesselTrack::rot() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.rot)
  return rot_;
}
inline void VesselTrack::set_rot(float value) {
  set_has_rot();
  rot_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.rot)
}

// required float sog = 6;
inline bool VesselTrack::has_sog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VesselTrack::set_has_sog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VesselTrack::clear_has_sog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VesselTrack::clear_sog() {
  sog_ = 0;
  clear_has_sog();
}
inline float VesselTrack::sog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.sog)
  return sog_;
}
inline void VesselTrack::set_sog(float value) {
  set_has_sog();
  sog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.sog)
}

// required float lon = 7;
inline bool VesselTrack::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VesselTrack::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VesselTrack::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VesselTrack::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float VesselTrack::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.lon)
  return lon_;
}
inline void VesselTrack::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.lon)
}

// required float lat = 8;
inline bool VesselTrack::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VesselTrack::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VesselTrack::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VesselTrack::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float VesselTrack::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.lat)
  return lat_;
}
inline void VesselTrack::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.lat)
}

// required float cog = 9;
inline bool VesselTrack::has_cog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VesselTrack::set_has_cog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VesselTrack::clear_has_cog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VesselTrack::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline float VesselTrack::cog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.cog)
  return cog_;
}
inline void VesselTrack::set_cog(float value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.cog)
}

// required float heading = 10;
inline bool VesselTrack::has_heading() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VesselTrack::set_has_heading() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VesselTrack::clear_has_heading() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VesselTrack::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float VesselTrack::heading() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.heading)
  return heading_;
}
inline void VesselTrack::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.heading)
}

// required uint64 UTC = 11;
inline bool VesselTrack::has_utc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VesselTrack::set_has_utc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VesselTrack::clear_has_utc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VesselTrack::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 VesselTrack::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.UTC)
  return utc_;
}
inline void VesselTrack::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.UTC)
}

// -------------------------------------------------------------------

// AIS

// required int32 flag = 1;
inline bool AIS::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIS::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIS::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIS::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 AIS::flag() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.flag)
  return flag_;
}
inline void AIS::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AIS.flag)
}

// required string sourceId = 2;
inline bool AIS::has_sourceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIS::set_has_sourceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIS::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIS::clear_sourceid() {
  if (sourceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_->clear();
  }
  clear_has_sourceid();
}
inline const ::std::string& AIS::sourceid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.sourceId)
  return *sourceid_;
}
inline void AIS::set_sourceid(const ::std::string& value) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AIS.sourceId)
}
inline void AIS::set_sourceid(const char* value) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AIS.sourceId)
}
inline void AIS::set_sourceid(const char* value, size_t size) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AIS.sourceId)
}
inline ::std::string* AIS::mutable_sourceid() {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.sourceId)
  return sourceid_;
}
inline ::std::string* AIS::release_sourceid() {
  clear_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sourceid_;
    sourceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AIS::set_allocated_sourceid(::std::string* sourceid) {
  if (sourceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sourceid_;
  }
  if (sourceid) {
    set_has_sourceid();
    sourceid_ = sourceid;
  } else {
    clear_has_sourceid();
    sourceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.sourceId)
}

// optional .com.zhichenhaixin.proto.VesselInfo vesselInfo = 3;
inline bool AIS::has_vesselinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIS::set_has_vesselinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIS::clear_has_vesselinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIS::clear_vesselinfo() {
  if (vesselinfo_ != NULL) vesselinfo_->::com::zhichenhaixin::proto::VesselInfo::Clear();
  clear_has_vesselinfo();
}
inline const ::com::zhichenhaixin::proto::VesselInfo& AIS::vesselinfo() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.vesselInfo)
  return vesselinfo_ != NULL ? *vesselinfo_ : *default_instance_->vesselinfo_;
}
inline ::com::zhichenhaixin::proto::VesselInfo* AIS::mutable_vesselinfo() {
  set_has_vesselinfo();
  if (vesselinfo_ == NULL) vesselinfo_ = new ::com::zhichenhaixin::proto::VesselInfo;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.vesselInfo)
  return vesselinfo_;
}
inline ::com::zhichenhaixin::proto::VesselInfo* AIS::release_vesselinfo() {
  clear_has_vesselinfo();
  ::com::zhichenhaixin::proto::VesselInfo* temp = vesselinfo_;
  vesselinfo_ = NULL;
  return temp;
}
inline void AIS::set_allocated_vesselinfo(::com::zhichenhaixin::proto::VesselInfo* vesselinfo) {
  delete vesselinfo_;
  vesselinfo_ = vesselinfo;
  if (vesselinfo) {
    set_has_vesselinfo();
  } else {
    clear_has_vesselinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.vesselInfo)
}

// optional .com.zhichenhaixin.proto.VesselTrack vesselTrack = 4;
inline bool AIS::has_vesseltrack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIS::set_has_vesseltrack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIS::clear_has_vesseltrack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIS::clear_vesseltrack() {
  if (vesseltrack_ != NULL) vesseltrack_->::com::zhichenhaixin::proto::VesselTrack::Clear();
  clear_has_vesseltrack();
}
inline const ::com::zhichenhaixin::proto::VesselTrack& AIS::vesseltrack() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.vesselTrack)
  return vesseltrack_ != NULL ? *vesseltrack_ : *default_instance_->vesseltrack_;
}
inline ::com::zhichenhaixin::proto::VesselTrack* AIS::mutable_vesseltrack() {
  set_has_vesseltrack();
  if (vesseltrack_ == NULL) vesseltrack_ = new ::com::zhichenhaixin::proto::VesselTrack;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.vesselTrack)
  return vesseltrack_;
}
inline ::com::zhichenhaixin::proto::VesselTrack* AIS::release_vesseltrack() {
  clear_has_vesseltrack();
  ::com::zhichenhaixin::proto::VesselTrack* temp = vesseltrack_;
  vesseltrack_ = NULL;
  return temp;
}
inline void AIS::set_allocated_vesseltrack(::com::zhichenhaixin::proto::VesselTrack* vesseltrack) {
  delete vesseltrack_;
  vesseltrack_ = vesseltrack;
  if (vesseltrack) {
    set_has_vesseltrack();
  } else {
    clear_has_vesseltrack();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.vesselTrack)
}

// -------------------------------------------------------------------

// AISList

// required uint64 UTC = 1;
inline bool AISList::has_utc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISList::set_has_utc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISList::clear_has_utc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISList::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AISList::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISList.UTC)
  return utc_;
}
inline void AISList::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISList.UTC)
}

// repeated .com.zhichenhaixin.proto.AIS ais = 2;
inline int AISList::ais_size() const {
  return ais_.size();
}
inline void AISList::clear_ais() {
  ais_.Clear();
}
inline const ::com::zhichenhaixin::proto::AIS& AISList::ais(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Get(index);
}
inline ::com::zhichenhaixin::proto::AIS* AISList::mutable_ais(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AIS* AISList::add_ais() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >&
AISList::ais() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISList.ais)
  return ais_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >*
AISList::mutable_ais() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISList.ais)
  return &ais_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace zhichenhaixin
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::zhichenhaixin::proto::EPFD> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::zhichenhaixin::proto::EPFD>() {
  return ::com::zhichenhaixin::proto::EPFD_descriptor();
}
template <> struct is_proto_enum< ::com::zhichenhaixin::proto::NAVI_STATUS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::zhichenhaixin::proto::NAVI_STATUS>() {
  return ::com::zhichenhaixin::proto::NAVI_STATUS_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED
